--- 
title: 'TMA4315: Compulsory exercise 2 Logistic regression and Poisson regression'
output:
  pdf_document:
    toc: yes
    toc_depth: '2'
  html_document:
    toc: yes
    toc_depth: 2
    toc_float: yes
date: "`r format(Sys.time(), '%d.%m.%Y')`"
subtitle: 'Group XX: Henrik Syversveen Lie, Mikal Stapnes, Oliver Byhring'
---


```{r setup, include = FALSE}
library(formatR)
showsol <- FALSE
library(knitr)
opts_chunk$set(tidy.opts = list(width.cutoff = 68), tidy = TRUE, warning = FALSE, error = FALSE, message = FALSE, echo = TRUE)
```

# Part 1: Logistic regression

## a)

We let $y_i$ be the number of successfull ascents, and $n_i$ be the total number of attempts (success + fail) of the i'th mountain. We then do binary regression with the logit link to model the probability of success. This gives

1. Model for response: $Y_i \sim \text{Bin}(n_i,\pi_i), \quad \text{for } i = 1,\dots,113$
2. Linear predictor: $\eta_i = {\bf x} _i^T \beta$
3. Link function: $\eta_i = \ln(\frac{\pi_i}{1-\pi_i})$

where $x_i$ is a $p$ dimensional column vector of covariates for observation $i$, and $\beta$ is the vector of regression parameters.

# Part 2: Poisson regression - Eliteserien 2018

## a)
We want to test if the assumption of independence between the goals made by the home and away teams is reasonable. To do this, we first load the data set and make a contingency table of all the results, with the goals of the home team on the rows, and goals of the away team on the columns. We get the following contingency table.
```{r, echo = F, eval = T}
filepath <- "https://www.math.ntnu.no/emner/TMA4315/2018h/eliteserien2018"
eliteserie <- read.table(file = filepath, header = TRUE, colClasses = c("character", 
    "character", "numeric", "numeric"))
contingency = matrix(rep(0,25),nrow = 5, ncol = 5)
rownames(contingency) = c("0","1","2","3","4+")
colnames(contingency) = c("0","1","2","3","4+")

for (i in 1:dim(eliteserie)[1]){
  if (eliteserie[i,3]<4 & eliteserie[i,4]<4){
    contingency[eliteserie[i,3]+1,eliteserie[i,4]+1] = contingency[eliteserie[i,3]+1,eliteserie[i,4]+1]+1
  }  else if (eliteserie[i,3]<4 & !eliteserie[i,4]<4){
    contingency[eliteserie[i,3]+1,5] = contingency[eliteserie[i,3]+1,5] + 1
  }  else if (!eliteserie[i,3]<4 & eliteserie[i,4]<4){
    contingency[5,eliteserie[i,4]+1] = contingency[5, eliteserie[i,4]+1] + 1
  }  else{
    contingency[5,5] = contingency[5,5] + 1
  }
}
print(contingency)

```

We then want to test if the number of goals for home and away team are independent. We do this by conducting _Pearson's_ $\chi^2$ _test_ on the contingency table. The test poses the following hypotheses (SPØR OM DETTE ER RIKTIG HYPOTESE)
$$H_0: \text{The sampling distributions are independently chi-squared distributed}, \quad H_1: \text{They are not independently chi-squared distributed}.$$

```{r, echo = F, eval = T}
Xsq <- chisq.test(contingency)
print(Xsq)
```
We get a value of $14.146$ for the test statistic, with a corresponding p-value of 0.5871. As this p-value is above any reasonable significance level, we keep the null hypothesis, and confirm that the goals scored by the home and away team are independent.


## b)
We now make the current standings in the Eliteserie based on all the results in our data set, and get the following table.
```{r, echo = F, eval = T}
ranking = data.frame(
  Team = c("Rosenborg", "Molde", "Lillestroem", "Odd", "Haugesund", "Sandefjord_Fotball", "Ranheim_TF", "Brann", "Sarpsborg08", "Stabaek", "Tromsoe", "Start", "Vaalerenga", "Kristiansund", "Stroemsgodset", "BodoeGlimt"), 
  Played = 0,
  Won = 0,
  Drawn = 0,
  Lost = 0,
  For = 0,
  Against = 0,
  GD = 0,
  Points = 0,
  stringsAsFactors = FALSE)

for (i in 1:dim(eliteserie)[1]){
  # First add number of matches played for both home team
  ranking[match(eliteserie[i,1], ranking[,1]),2] = ranking[match(eliteserie[i,1], ranking[,1]),2] + 1
  # and for the away team
  ranking[match(eliteserie[i,2], ranking[,1]),2] = ranking[match(eliteserie[i,2], ranking[,1]),2] + 1
  
  # Then add goals for and against home team
  ranking[match(eliteserie[i,1], ranking[,1]),6] = ranking[match(eliteserie[i,1], ranking[,1]),6] + eliteserie[i,3]
  ranking[match(eliteserie[i,1], ranking[,1]),7] = ranking[match(eliteserie[i,1], ranking[,1]),7] + eliteserie[i,4]
  # and for and against away team
  ranking[match(eliteserie[i,2], ranking[,1]),6] = ranking[match(eliteserie[i,2], ranking[,1]),6] + eliteserie[i,4]
  ranking[match(eliteserie[i,2], ranking[,1]),7] = ranking[match(eliteserie[i,2], ranking[,1]),7] + eliteserie[i,3]
  
  # Then count wins, draws and losses for home team
  ranking[match(eliteserie[i,1], ranking[,1]),3] = ranking[match(eliteserie[i,1], ranking[,1]),3] + as.numeric(eliteserie[i,3]>eliteserie[i,4])
  ranking[match(eliteserie[i,1], ranking[,1]),4] = ranking[match(eliteserie[i,1], ranking[,1]),4] + as.numeric(eliteserie[i,3]==eliteserie[i,4])
  ranking[match(eliteserie[i,1], ranking[,1]),5] = ranking[match(eliteserie[i,1], ranking[,1]),5] + as.numeric(eliteserie[i,4]>eliteserie[i,3])
  
  # Finally count wins, draws and losses for away team
  ranking[match(eliteserie[i,2], ranking[,1]),3] = ranking[match(eliteserie[i,2], ranking[,1]),3] + as.numeric(eliteserie[i,3]<eliteserie[i,4])
  ranking[match(eliteserie[i,2], ranking[,1]),4] = ranking[match(eliteserie[i,2], ranking[,1]),4] + as.numeric(eliteserie[i,3]==eliteserie[i,4])
  ranking[match(eliteserie[i,2], ranking[,1]),5] = ranking[match(eliteserie[i,2], ranking[,1]),5] + as.numeric(eliteserie[i,4]<eliteserie[i,3])
}
# Points is computed by 3 points for win, 1 for draw and 0 for loss
ranking[,9] = 3*ranking[,3] + ranking[,4]
# Goal difference is goals scored minus goals conceded
ranking[,8] = ranking[,6] - ranking[,7]
# We rank the teams first by points, then goal difference, finally by goals scored
ranking = ranking[order(ranking$Points, ranking$GD, ranking$For, decreasing = T),]
# Rename rows after sorting
row.names(ranking) <- seq(1,16)
print(ranking)
```


## c)

```{r, echo = F, eval = T}
X = matrix(0, nrow = dim(eliteserie)[1]*2, ncol = 18)
colnames(X) = c("Intercept", "HomeAdvantage", "Rosenborg", "Molde", "Lillestroem", "Odd", "Haugesund", "Sandefjord_Fotball", "Ranheim_TF", "Brann", "Sarpsborg08", "Stabaek", "Tromsoe", "Start", "Vaalerenga", "Kristiansund", "Stroemsgodset", "BodoeGlimt")

# First we alter the design matrix for all home teams
for (i in 1:dim(eliteserie)[1]){
  # Intercept
  X[i,1] = 1
  
  # Home team gets x_home = 1
  X[i,2] = 1
  
  # x_home is set to 1
  X[i, match(eliteserie[i,1], dimnames(X)[[2]])] = 1
  
  # x_away is set to -1
  X[i, match(eliteserie[i,2], dimnames(X)[[2]])] = -1
}

# Then alter design matrix for all away teams
for (i in 1:dim(eliteserie)[1]){
  # Intercept
  X[dim(eliteserie)[1] + i,1] = 1
  
  # Away team, so x_home = 0
  
  # x_home is set to -1
  X[dim(eliteserie)[1] + i, match(eliteserie[i,1], dimnames(X)[[2]])] = -1
  
  # x_away is set to 1
  X[dim(eliteserie)[1] + i, match(eliteserie[i,2], dimnames(X)[[2]])] = 1
}

# And we now have the desired design matrix

# We then make the response vector
goals = c(eliteserie[,3], eliteserie[,4])

# Finally we create the function that does the regression
myglm <- function(formula, data = list(), contrasts = NULL, ...){
  
  # Extract model matrix & responses
  mf <- model.frame(formula = formula, data = data)
  X  <- model.matrix(attr(mf, "terms"), data = mf, contrasts.arg = contrasts)
  y  <- model.response(mf)
  terms <- attr(mf, "terms")

  # Add code here to calculate coefficients, residuals, fitted values, etc...
  # and store the results in the list est
  est <- list(terms = terms, model = mf)

  # Store call and formula used
  est$call <- match.call()
  est$formula <- formula

  # Store information used for model fit
  est$X <- X
  est$y <- y
  
  #Fit model (using optim function in r)
  est$initial <- rep(0,18)
  est$fcn <- function(coeff){
    return(-y%*%X%*%coeff + sum(exp(X%*%coeff)))
  }
  est$coefficients = optim(est$initial, est$fcn, method = "BFGS", hessian = TRUE)
  
  return(est$coefficients)
}

coeff <- myglm(goals~ -1 + X)

# Find relative strength by setting Bodø Glimt to 0
coeff$par[3:17] = coeff$par[3:17] - coeff$par[18]
coeff$par[18] = 0

powerRanking = data.frame(
  Team = c("Rosenborg", "Molde", "Lillestroem", "Odd", "Haugesund", "Sandefjord_Fotball", "Ranheim_TF", "Brann", "Sarpsborg08", "Stabaek", "Tromsoe", "Start", "Vaalerenga", "Kristiansund", "Stroemsgodset", "BodoeGlimt"),
  Power = coeff$par[3:18],
  stringsAsFactors = FALSE)


# Sort after strength
powerRanking = powerRanking[order(powerRanking$Power, decreasing = T),]
# Rename rows after sorting
row.names(powerRanking) <- seq(1,16)

print(powerRanking)
print("Intercept: ")
print(coeff$par[1])
print("Home advantage: ")
print(coeff$par[2])

compareableRanking = data.frame(
  Power = powerRanking[,1],
  Ranking = ranking[,1],
  stringsAsFactors = FALSE)
row.names(compareableRanking) <- seq(1,16)
print(compareableRanking)

summary(glm(goals ~ -1 + X, family = "poisson"))

```

DISCUSS THE RESULTS FROM THIS TASK

## d)


```{r, echo = F, eval = T}
# Load the unplayed matches
filepath <- "https://www.math.ntnu.no/emner/TMA4315/2018h/unplayed2018"
eliteserieUnplayed <- read.table(file = filepath, header = TRUE, colClasses = c("character", 
    "character"))

# Add columns for goals in each match
eliteserieUnplayed$yh = rep(0,dim(eliteserieUnplayed)[1])
eliteserieUnplayed$ya = rep(0,dim(eliteserieUnplayed)[1])

fotball <- list()

simseason <- function(){
  #Play the remaining matches
  eliteserieUnplayed[,3] = rpois(dim(eliteserieUnplayed)[1],exp(coeff$par[1]+coeff$par[2] + powerRanking[match(eliteserieUnplayed[,1], powerRanking$Team),2] - powerRanking[match(eliteserieUnplayed[,2], powerRanking$Team),2]))
  eliteserieUnplayed[,4] = rpois(dim(eliteserieUnplayed)[1],exp(coeff$par[1] - powerRanking[match(eliteserieUnplayed[,1], powerRanking$Team),2] + powerRanking[match(eliteserieUnplayed[,2], powerRanking$Team),2]))
  
  
  
  # Make the final ranking by starting with the matches already played
  rankingFinal <- ranking
  # Each team will play 30 times
  rankingFinal$Played = rep(30,16)
  
  for (i in 1:dim(eliteserieUnplayed)[1]){
    # Add goals for and against home team
    rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),6] = rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),6] + eliteserieUnplayed[i,3]
    rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),7] = rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),7] + eliteserieUnplayed[i,4]
    # and for and against away team
    rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),6] = rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),6] + eliteserieUnplayed[i,4]
    rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),7] = rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),7] + eliteserieUnplayed[i,3]
  
    # Then count wins, draws and losses for home team
    rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),3] = rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),3] + as.numeric(eliteserieUnplayed[i,3]>eliteserieUnplayed[i,4])
    rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),4] = rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),4] + as.numeric(eliteserieUnplayed[i,3]==eliteserieUnplayed[i,4])
    rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),5] = rankingFinal[match(eliteserieUnplayed[i,1], rankingFinal[,1]),5] + as.numeric(eliteserieUnplayed[i,4]>eliteserieUnplayed[i,3])
  
    # Finally count wins, draws and losses for away team
    rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),3] = rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),3] + as.numeric(eliteserieUnplayed[i,3]<eliteserieUnplayed[i,4])
    rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),4] = rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),4] + as.numeric(eliteserieUnplayed[i,3]==eliteserieUnplayed[i,4])
    rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),5] = rankingFinal[match(eliteserieUnplayed[i,2], rankingFinal[,1]),5] + as.numeric(eliteserieUnplayed[i,4]<eliteserieUnplayed[i,3])
  }
  # Points is computed by 3 points for win, 1 for draw and 0 for loss
  rankingFinal[,9] = 3*rankingFinal[,3] + rankingFinal[,4]
  # Goal difference is goals scored minus goals conceded
  rankingFinal[,8] = rankingFinal[,6] - rankingFinal[,7]
  # We rank the teams first by points, then goal difference, finally by goals scored
  rankingFinal = rankingFinal[order(rankingFinal$Points, rankingFinal$GD, rankingFinal$For, decreasing = T),]
  # Rename rows after sorting
  row.names(rankingFinal) <- seq(1,16)
  return(rankingFinal)
}

set.seed(4315)
# for (i in 1:1000){
#  fotball[[i]] <- simseason()
# }

#saveRDS(fotball, file = "Simulering.rds")
```


```{r, echo = F, eval = T}


data = readRDS(file = "Simulering.rds")

rankingAverage <- data.frame(
    Team = c("Rosenborg", "Molde", "Lillestroem", "Odd", "Haugesund", "Sandefjord_Fotball", "Ranheim_TF", "Brann", "Sarpsborg08", "Stabaek", "Tromsoe", "Start", "Vaalerenga", "Kristiansund", "Stroemsgodset", "BodoeGlimt"),
    Played = 30,
    Won = 0,
    Drawn = 0,
    Lost = 0,
    For = 0,
    Against = 0,
    GD = 0,
    Points = 0,
    stringsAsFactors = FALSE)

#Number of times each team placed in each place
numPlace = data.frame(
  Team = c("Rosenborg", "Brann", "Molde", "Haugesund", "Ranheim_TF", "Vaalerenga", "Odd", "Tromsoe", "Sarpsborg08", "Kristiansund", "Stroemsgodset", "BodoeGlimt", "Lillestroem", "Stabaek", "Start", "Sandefjord_Fotball"),
    One = 0, Two = 0, Three = 0, Four = 0, Five = 0, Six = 0, Seven = 0, Eight = 0, Nine = 0, Ten = 0, Eleven = 0, Twelve = 0, Thirteen = 0, Fourteen = 0, Fifteen = 0, Sixteen = 0,
    stringsAsFactors = FALSE)


placings = data.frame(Rosenborg = rep(0,1000), Brann = rep(0,1000), Molde = rep(0,1000), Haugesund = rep(0,1000), Ranheim_TF = rep(0,1000), Vaalerenga = rep(0,1000), Odd = rep(0,1000), Tromsoe = rep(0,1000), Sarpsborg08 = rep(0,1000), Kristiansund = rep(0,1000), Stroemsgodset = rep(0,1000), BodoeGlimt = rep(0,1000), Lillestroem = rep(0,1000), Stabaek = rep(0,1000), Start = rep(0,1000), Sandefjord_Fotball = rep(0,1000))

points = data.frame(Rosenborg = rep(0,1000), Brann = rep(0,1000), Molde = rep(0,1000), Haugesund = rep(0,1000), Ranheim_TF = rep(0,1000), Vaalerenga = rep(0,1000), Odd = rep(0,1000), Tromsoe = rep(0,1000), Sarpsborg08 = rep(0,1000), Kristiansund = rep(0,1000), Stroemsgodset = rep(0,1000), BodoeGlimt = rep(0,1000), Lillestroem = rep(0,1000), Stabaek = rep(0,1000), Start = rep(0,1000), Sandefjord_Fotball = rep(0,1000))


# Average the table over all the simulations:
# And calculate number of times each team placed in each place
for (i in 1:1000){
  cur = data[[i]]
  for (j in 1:16){
    placings[i,match(cur[j,1],colnames(placings))] = j
    points[i,match(cur[j,1],colnames(points))] = cur[j,9]
    numPlace[match(cur[j,1], numPlace[,1]),j+1] = numPlace[match(cur[j,1], numPlace[,1]),j+1] + 1
    rankingAverage[match(cur[j,1], rankingAverage[,1]),3] = rankingAverage[match(cur[j,1], rankingAverage[,1]),3] + cur[j,3]/1000
    rankingAverage[match(cur[j,1], rankingAverage[,1]),4] = rankingAverage[match(cur[j,1], rankingAverage[,1]),4] + cur[j,4]/1000
    rankingAverage[match(cur[j,1], rankingAverage[,1]),5] = rankingAverage[match(cur[j,1], rankingAverage[,1]),5] + cur[j,5]/1000
    rankingAverage[match(cur[j,1], rankingAverage[,1]),6] = rankingAverage[match(cur[j,1], rankingAverage[,1]),6] + cur[j,6]/1000
    rankingAverage[match(cur[j,1], rankingAverage[,1]),7] = rankingAverage[match(cur[j,1], rankingAverage[,1]),7] + cur[j,7]/1000
    rankingAverage[match(cur[j,1], rankingAverage[,1]),8] = rankingAverage[match(cur[j,1], rankingAverage[,1]),8] + cur[j,8]/1000
    rankingAverage[match(cur[j,1], rankingAverage[,1]),9] = rankingAverage[match(cur[j,1], rankingAverage[,1]),9] + cur[j,9]/1000
  }
}

# Sort the table in the right order
rankingAverage = rankingAverage[order(rankingAverage$Points, rankingAverage$GD, rankingAverage$For, decreasing = T),]
# Rename rows after sorting
row.names(rankingAverage) <- seq(1,16)

# Round to 1 decimal
rankingAverage[,2:9] = round(rankingAverage[,2:9],1)

head(points)
print(rankingAverage)
print(numPlace)

```

```{r,echo=F,eval=T}
library("ggplot2")
library("reshape2")

ggplot(numPlace, aes(x = seq(1:16))) + geom_line(aes(y = t(numPlace[1,2:17]), colour = numPlace[1,1])) + geom_line(aes(y = t(numPlace[2,2:17]), colour = numPlace[2,1])) + geom_line(aes(y = t(numPlace[3,2:17]), colour = numPlace[3,1])) + geom_line(aes(y = t(numPlace[4,2:17]), colour = numPlace[4,1])) + geom_line(aes(y = t(numPlace[5,2:17]), colour = numPlace[5,1])) + geom_line(aes(y = t(numPlace[6,2:17]), colour = numPlace[6,1])) + geom_line(aes(y = t(numPlace[7,2:17]), colour = numPlace[7,1])) + geom_line(aes(y = t(numPlace[8,2:17]), colour = numPlace[8,1])) + geom_line(aes(y = t(numPlace[9,2:17]), colour = numPlace[9,1])) + geom_line(aes(y = t(numPlace[10,2:17]), colour = numPlace[10,1])) + geom_line(aes(y = t(numPlace[11,2:17]), colour = numPlace[11,1])) + geom_line(aes(y = t(numPlace[12,2:17]), colour = numPlace[12,1])) + geom_line(aes(y = t(numPlace[13,2:17]), colour = numPlace[13,1])) + geom_line(aes(y = t(numPlace[14,2:17]), colour = numPlace[14,1])) + geom_line(aes(y = t(numPlace[15,2:17]), colour = numPlace[15,1])) + geom_line(aes(y = t(numPlace[16,2:17]), colour = numPlace[16,1])) + labs(x = "Place", y = "Number of placings")

```

```{r, echo = F, eval = T}
# Plot the placings of each team in a barchart
placingsplot <- melt(placings)
ggplot(placingsplot, aes(x = value)) + geom_bar() + facet_wrap(~variable)
```


```{r, echo = F, eval = T}
# Plot the points of each team in a histogram
pointsplot <- melt(points)
ggplot(pointsplot, aes(x = value)) + geom_histogram() + facet_wrap(~variable)
```

By the histogram of points, the amount of points achieved in a season looks to be normal. Seeing as the amount of points is a random variable, we can by the central limit theorem say that the mean of the points is normally distributed. We therefore find the average number of points for each team, as well as the standard deviation, and construct 90 % confidence intervals for the points of each team.

```{r, echo = F, eval = T}
confidence_intervals = data.frame(
  Teams = numPlace[,1], # All the teams
  mean = 0,
  sd = 0,
  low = 0,
  high = 0,
  stringsAsFactors = FALSE)

for (i in 1:16){
  confidence_intervals$mean[i] = mean(points[[i]])
  confidence_intervals$sd[i] = sd(points[[i]])
  confidence_intervals$low[i] = confidence_intervals$mean[i] - confidence_intervals$sd[i]*1.645
  confidence_intervals$high[i] = confidence_intervals$mean[i] + confidence_intervals$sd[i]*1.645
  }

confidence_intervals[,2:5] = round(confidence_intervals[,2:5],1)
print(confidence_intervals)
```

